## 1. C++ STL unordered_map容器

​	哈希表存储的map，特点是一一对应，但没有大小关系，所以不会对容器内的元素进行排列
​	无序map在进行初始化时，至少要包括键和值两项，可用于快速查找（维持空间复杂度基本不变的情况下减少时间复杂度）

​	头文件：`#include<unorder_map>`
​	使用：`unordered_map<data_type1, data_type2> map;`
​	其中`data_type1`表示键值`key`，`data_type`表示内容值`val`
​	`map->first` ：key       `map->second`：val

## 2. 数组

​	数组在初始化时必须设置其大小，在动态设置数组时通常用vector（c++）

```c++
#include<vector>	
using namespace std;
	vector<int> array;	
```

​	在对数组进行如增添、替换等操作时，需要格外注意数组size的变化，如**剑指05**中当把字符串中的空格替换为%20时原数组的大小发生了变化，所以需要先确定变化后的数组大小，即先确定容器，再向容器里面装入数据。

## 3. 栈

​	栈结构的核心思想：先进后出

```c++
#include<stack>
using namespace std;
	stack<int> stk;
	stk.push(value); //将value压入底部
	stk.pop();		//将最新压入（最上方）的value弹出
	stk.empty();	//判断stack是否为空，若空则返回true
	stk.top();		//get the top_value of stack
```

​	由于栈先进后出的特殊结构，在涉及“反向”、“从尾到头”等算法实现时可以考虑利用栈结构。
​	栈结构的缺点：如果要获得第一个压入栈的数据，需要先将该数据上方的所有数据全部pop，效率低
​	利用**两个栈**可以实现一个**队列**（queue），如**剑指09**

## 4. 有限状态机（Finite-state machine, FSM）

​	当一件事可能会经过多个不同状态的转换，转换依赖于在不同时发生的不同事件触发时，可以考虑使用有限状态机。如**剑指20**

​	一个FSM中至少需要以下元素：

​	`State`：事件的不同状态

​	`Event`：事件，在某一特定条件下状态会发生变化

​	`Transition`：状态的转换过程

​	在java中可以用`Map[] states`数组来存储状态转移表

![image-20211104172958073](C:\Users\真\AppData\Roaming\Typora\typora-user-images\image-20211104172958073.png)

## 5. 递归的三条件，两步骤

三条件：

 	1. 大问题可以拆解成两个子问题
 	2. 子问题求解方式和大问题一样
 	3. 存在最小子问题

两步骤：

​	“递”：将大问题不断拆解为小问题

​	“归”：将小问题返回到整体

## 6. C++的字符串切片

```c++
#include<string>
using namespace std;
string s = "this is a test";
string sub = s.substr(0,2); //0为起始位置，2为子字符串的长度
char c = '!'
s.push_back(c);	//s:"this is a test!" 
```

